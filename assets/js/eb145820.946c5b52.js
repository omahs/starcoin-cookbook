"use strict";(self.webpackChunkstarcoin_cookbook=self.webpackChunkstarcoin_cookbook||[]).push([[5823],{3905:function(e,n,a){a.d(n,{Zo:function(){return p},kt:function(){return u}});var t=a(7294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function d(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),l=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},p=function(e){var n=l(e.components);return t.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),c=l(a),u=i,k=c["".concat(s,".").concat(u)]||c[u]||m[u]||o;return a?t.createElement(k,r(r({ref:n},p),{},{components:a})):t.createElement(k,r({ref:n},p))}));function u(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=c;var d={};for(var s in n)hasOwnProperty.call(n,s)&&(d[s]=n[s]);d.originalType=e,d.mdxType="string"==typeof e?e:i,r[1]=d;for(var l=2;l<o;l++)r[l]=a[l];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},6374:function(e,n,a){a.r(n),a.d(n,{assets:function(){return s},contentTitle:function(){return r},default:function(){return m},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return l}});var t=a(3117),i=(a(7294),a(3905));const o={},r="Packages",d={unversionedId:"move/move-language/packages",id:"move/move-language/packages",title:"Packages",description:"Packages allow Move programmers to more easily re-use code and share it",source:"@site/docs/03-move/03-move-language/01-packages.md",sourceDirName:"03-move/03-move-language",slug:"/move/move-language/packages",permalink:"/docs/move/move-language/packages",draft:!1,editUrl:"https://github.com/starcoinorg/starcoin-cookbook/edit/main/docs/03-move/03-move-language/01-packages.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Move Language",permalink:"/docs/move/move-language/"},next:{title:"Understanding abilities",permalink:"/docs/move/understanding-ability"}},s={},l=[{value:"Package Layout and Manifest Syntax",id:"package-layout-and-manifest-syntax",level:2},{value:"Move.toml",id:"movetoml",level:3},{value:"Named Addresses During Compilation",id:"named-addresses-during-compilation",level:2},{value:"Declaration",id:"declaration",level:3},{value:"Scoping and Renaming of Named Addresses",id:"scoping-and-renaming-of-named-addresses",level:2},{value:"Instantiation",id:"instantiation",level:3},{value:"Usage, Artifacts, and Data Structures",id:"usage-artifacts-and-data-structures",level:2},{value:"Usage",id:"usage",level:3}],p={toc:l};function m(e){let{components:n,...a}=e;return(0,i.kt)("wrapper",(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"packages"},"Packages"),(0,i.kt)("p",null,"Packages allow Move programmers to more easily re-use code and share it\nacross projects. The Move package system allows programmers to easily:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Define a package containing Move code;"),(0,i.kt)("li",{parentName:"ul"},"Parameterize a package by named addresses;"),(0,i.kt)("li",{parentName:"ul"},"Import and use packages in other Move code and instantiate named addresses;"),(0,i.kt)("li",{parentName:"ul"},"Build packages and generate associated compilation artifacts from packages; and"),(0,i.kt)("li",{parentName:"ul"},"Work with a common interface around compiled Move artifacts.")),(0,i.kt)("h2",{id:"package-layout-and-manifest-syntax"},"Package Layout and Manifest Syntax"),(0,i.kt)("p",null,"A Move package source directory contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"Move.toml")," package manifest\nfile along with a set of subdirectories:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"a_move_package\n\u251c\u2500\u2500 Move.toml      (required)\n\u251c\u2500\u2500 sources        (required)\n\u251c\u2500\u2500 examples       (optional, test & dev mode)\n\u251c\u2500\u2500 scripts        (optional)\n\u251c\u2500\u2500 doc_templates  (optional)\n\u2514\u2500\u2500 tests          (optional, test mode)\n")),(0,i.kt)("p",null,"The directories marked ",(0,i.kt)("inlineCode",{parentName:"p"},"required")," ",(0,i.kt)("em",{parentName:"p"},"must")," be present in order for the directory\nto be considered a Move package and to be compiled. Optional directories can\nbe present, and if so will be included in the compilation process. Depending on\nthe mode that the package is built with (",(0,i.kt)("inlineCode",{parentName:"p"},"test")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"dev"),"), the ",(0,i.kt)("inlineCode",{parentName:"p"},"tests")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"examples")," directories will be included as well."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"sources")," directory can contain both Move modules and Move scripts (both\ntransaction scripts and modules containing script functions). The ",(0,i.kt)("inlineCode",{parentName:"p"},"examples"),"\ndirectory can hold additional code to be used only for development and/or\ntutorial purposes that will not be included when compiled outside ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"dev")," mode."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"scripts")," directory is supported so transaction scripts can be separated\nfrom modules if that is desired by the package author. The ",(0,i.kt)("inlineCode",{parentName:"p"},"scripts"),"\ndirectory will always be included for compilation if it is present.\nDocumentation will be built using any documentation templates present in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"doc_templates")," directory."),(0,i.kt)("h3",{id:"movetoml"},"Move.toml"),(0,i.kt)("p",null,"The Move package manifest is defined within the ",(0,i.kt)("inlineCode",{parentName:"p"},"Move.toml")," file and has the\nfollowing syntax. Optional fields are marked with ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," denotes\none or more elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = <string>                  # e.g., "MoveStdlib"\nversion = "<uint>.<uint>.<uint>" # e.g., "0.1.1"\nlicense* = <string>              # e.g., "MIT", "GPL", "Apache 2.0"\nauthors* = [<string>]            # e.g., ["Joe Smith (joesmith@noemail.com)", "Jane Smith (janesmith@noemail.com)"]\n\n[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph\n# One or more lines declaring named addresses in the following format\n<addr_name> = "_" | "<hex_address>" # e.g., Std = "_" or Addr = "0xC0FFEECAFE"\n\n[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency\n# One or more lines declaring dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # local dependencies\n<string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # git dependencies\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in "dev" and "test" modes\n# One or more lines declaring dev named addresses in the following format\n<addr_name> = "_" | "<hex_address>" # e.g., Std = "_" or Addr = "0xC0FFEECAFE"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in "dev" and "test" modes\n# One or more lines declaring dev dependencies in the following format\n<string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }\n')),(0,i.kt)("p",null,"An example of a minimal package manifest with one local dependency and one git dependency:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "AName"\nversion = "0.0.0"\n')),(0,i.kt)("p",null,"An example of a more standard package manifest that also includes the Move\nstandard library and instantiates the named address ",(0,i.kt)("inlineCode",{parentName:"p"},"Std")," from it with the\naddress value ",(0,i.kt)("inlineCode",{parentName:"p"},"0x1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "AName"\nversion = "0.0.0"\nlicense = "Apache 2.0"\n\n[addresses]\nAddressToBeFilledIn = "_"\nSpecifiedAddress = "0xB0B"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = "projects/move-awesomeness", addr_subst = { "Std" = "0x1" } }\n# Git dependency\nMoveStdlib = { git = "https://github.com/diem/diem.git", subdir="language/move-stdlib", rev = "56ab033cc403b489e891424a629e76f643d4fb6b" }\n\n[dev-addresses] # For use when developing this module\nAddressToBeFilledIn = "0x101010101"\n')),(0,i.kt)("p",null,"Most of the sections in the package manifest are self explanatory, but named\naddresses can be a bit difficult to understand so it's worth examining them in\na bit more detail."),(0,i.kt)("h2",{id:"named-addresses-during-compilation"},"Named Addresses During Compilation"),(0,i.kt)("p",null,"Recall that Move has named addresses and that\nnamed addresses cannot be declared in Move. Because of this, until now\nnamed addresses and their values needed to be passed to the compiler on the\ncommand line. With the Move package system this is no longer needed, and\nyou can declare named addresses in the package, instantiate other named\naddresses in scope, and rename named addresses from other packages within\nthe Move package system manifest file. Let's go through each of these\nindividually:"),(0,i.kt)("h3",{id:"declaration"},"Declaration"),(0,i.kt)("p",null,"Let's say we have a Move module in ",(0,i.kt)("inlineCode",{parentName:"p"},"example_pkg/sources/A.move")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-move"},"module NamedAddr::A {\n    public fun x(): address { @NamedAddr }\n}\n")),(0,i.kt)("p",null,"We could in ",(0,i.kt)("inlineCode",{parentName:"p"},"example_pkg/Move.toml")," declare the named address ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," in\ntwo different ways. The first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "ExamplePkg"\n...\n[addresses]\nNamedAddr = "_"\n')),(0,i.kt)("p",null,"Declares ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," as a named address in the package ",(0,i.kt)("inlineCode",{parentName:"p"},"ExamplePkg")," and\nthat ",(0,i.kt)("em",{parentName:"p"},"this address can be any valid address value"),". Therefore an importing\npackage can pick the value of the named address ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," to be any address\nit wishes. Intuitively you can think of this as parameterizing the package\n",(0,i.kt)("inlineCode",{parentName:"p"},"ExamplePkg")," by the named address ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr"),", and the package can then be\ninstantiated later on by an importing package."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," can also be declared as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "ExamplePkg"\n...\n[addresses]\nNamedAddr = "0xCAFE"\n')),(0,i.kt)("p",null,"which states that the named address ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," is exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"0xCAFE")," and cannot be\nchanged. This is useful so other importing packages can use this named\naddress without needing to worry about the exact value assigned to it."),(0,i.kt)("p",null,"With these two different declaration methods, there are two ways that\ninformation about named addresses can flow in the package graph:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'The former ("unassigned named addresses") allows named address values to flow\nfrom the importation site to the declaration site.'),(0,i.kt)("li",{parentName:"ul"},'The latter ("assigned named addresses") allows named address values to flow\nfrom the declaration site upwards in the package graph to usage sites.')),(0,i.kt)("p",null,"With these two methods for flowing named address information throughout the\npackage graph the rules around scoping and renaming become important to\nunderstand."),(0,i.kt)("h2",{id:"scoping-and-renaming-of-named-addresses"},"Scoping and Renaming of Named Addresses"),(0,i.kt)("p",null,"A named address ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," in a package ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," is in scope if:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"It declares a named address ",(0,i.kt)("inlineCode",{parentName:"li"},"N"),"; or"),(0,i.kt)("li",{parentName:"ol"},"A package in one of ",(0,i.kt)("inlineCode",{parentName:"li"},"P"),"'s transitive dependencies declares the named address\n",(0,i.kt)("inlineCode",{parentName:"li"},"N")," and there is a dependency path in the package graph between between ",(0,i.kt)("inlineCode",{parentName:"li"},"P")," and the\ndeclaring package of ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," with no renaming of ",(0,i.kt)("inlineCode",{parentName:"li"},"N"),".")),(0,i.kt)("p",null,"Additionally, every named address in a package is exported. Because of this and\nthe above scoping rules each package can be viewed as coming with a set of\nnamed addresses that will be brought into scope when the package is imported,\ne.g., if the ",(0,i.kt)("inlineCode",{parentName:"p"},"ExamplePkg")," package was imported, that importation would bring\ninto scope the ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," named address. Because of this, if ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," imports two\npackages ",(0,i.kt)("inlineCode",{parentName:"p"},"P1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"P2")," both of which declare a named address ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," an issue\narises in ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),': which "',(0,i.kt)("inlineCode",{parentName:"p"},"N"),'" is meant when ',(0,i.kt)("inlineCode",{parentName:"p"},"N")," is referred to in ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),"? The one\nfrom ",(0,i.kt)("inlineCode",{parentName:"p"},"P1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"P2"),"? To prevent this ambiguity around which package a named\naddress is coming from, we enforce that the sets of scopes introduced by all\ndependencies in a package are disjoint, and provide a way to ",(0,i.kt)("em",{parentName:"p"},"rename named\naddresses")," when the package that brings them into scope is imported."),(0,i.kt)("p",null,"Renaming a named address when importing can be done as follows in our ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"P1"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"P2")," example above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "P"\n...\n[dependencies]\nP1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }\nP2 = { local = "some_path_to_P2"  }\n')),(0,i.kt)("p",null,"With this renaming ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," refers to the ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"P2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"P1N")," will refer to ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),"\ncoming from ",(0,i.kt)("inlineCode",{parentName:"p"},"P1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"module N::A {\n    public fun x(): address { @P1N }\n}\n")),(0,i.kt)("p",null,"It is important to note that ",(0,i.kt)("em",{parentName:"p"},"renaming is not local"),": once a named address ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),"\nhas been renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"N2")," in a package ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," all packages that import ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," will not\nsee ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," but only ",(0,i.kt)("inlineCode",{parentName:"p"},"N2")," unless ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is reintroduced from outside of ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),'. This is\nwhy rule (2) in the scoping rules at the start of this section specifies a\n"dependency path in the package graph between between ',(0,i.kt)("inlineCode",{parentName:"p"},"P")," and the declaring\npackage of ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," with no renaming of ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),'."'),(0,i.kt)("h3",{id:"instantiation"},"Instantiation"),(0,i.kt)("p",null,"Named addresses can be instantiated multiple times across the package graph as\nlong as it is always with the same value. It is an error if the same named\naddress (regardless of renaming) is instantiated with differing values across\nthe package graph."),(0,i.kt)("p",null,"A Move package can only be compiled if all named addresses resolve to a value.\nThis presents issues if the package wishes to expose an uninstantiated named\naddress. This is what the ",(0,i.kt)("inlineCode",{parentName:"p"},"[dev-addresses]")," section solves. This section can\nset values for named addresses, but cannot introduce any named addresses.\nAdditionally, only the ",(0,i.kt)("inlineCode",{parentName:"p"},"[dev-addresses]")," in the root package are included in\n",(0,i.kt)("inlineCode",{parentName:"p"},"dev")," mode. For example a root package with the following manifest would not compile\noutside of ",(0,i.kt)("inlineCode",{parentName:"p"},"dev")," mode since ",(0,i.kt)("inlineCode",{parentName:"p"},"NamedAddr")," would be uninstantiated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'[package]\nname = "ExamplePkg"\n...\n[addresses]\nNamedAddr = "_"\n\n[dev-addresses]\nNamedAddr = "0xC0FFEE"\n')),(0,i.kt)("h2",{id:"usage-artifacts-and-data-structures"},"Usage, Artifacts, and Data Structures"),(0,i.kt)("p",null,"The Move package system comes with a command line option as part of the Move\nCLI ",(0,i.kt)("inlineCode",{parentName:"p"},"move package <package_flags> <command> <command_flags>"),". Unless a\nparticular path is provided, all package commands will run in the current working\ndirectory. The full list of commands and flags for the Move Package CLI can be found by\nrunning ",(0,i.kt)("inlineCode",{parentName:"p"},"move package --help"),"."),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("p",null,"A package can be compiled either through the Move CLI commands, or as a library\ncommand in Rust with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"compile_package"),". This will create a\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompiledPackage")," that holds the compiled bytecode along with other compilation\nartifacts (source maps, documentation, ABIs) in memory. This ",(0,i.kt)("inlineCode",{parentName:"p"},"CompiledPackage"),"\ncan be converted to an ",(0,i.kt)("inlineCode",{parentName:"p"},"OnDiskPackage")," and vice versa -- the latter being the data of\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"CompiledPackage")," laid out in the file system in the following format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"a_move_package\n\u251c\u2500\u2500 Move.toml\n...\n\u2514\u2500\u2500 build\n    \u251c\u2500\u2500 <dep_pkg_name>\n    \u2502\xa0\xa0 \u251c\u2500\u2500 BuildInfo.yaml\n    \u2502\xa0\xa0 \u251c\u2500\u2500 bytecode_modules\n    \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.mv\n    \u2502\xa0\xa0 \u251c\u2500\u2500 source_maps\n    \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.mvsm\n    \u2502   \u251c\u2500\u2500 bytecode_scripts\n    \u2502   \u2502\xa0\xa0 \u2514\u2500\u2500 *.mv\n    \u2502   \u251c\u2500\u2500 abis\n    \u2502   \u2502\xa0\xa0 \u251c\u2500\u2500 *.abi\n    \u2502   \u2502\xa0\xa0 \u2514\u2500\u2500 <module_name>/*.abi\n    \u2502\xa0\xa0 \u2514\u2500\u2500 sources\n    \u2502\xa0\xa0     \u2514\u2500\u2500 *.move\n    ...\n    \u2514\u2500\u2500 <dep_pkg_name>\n        \u251c\u2500\u2500 BuildInfo.yaml\n        ...\n        \u2514\u2500\u2500 sources\n")),(0,i.kt)("p",null,"See the ",(0,i.kt)("inlineCode",{parentName:"p"},"move-package")," crate for more information on these data structures and\nhow to use the Move package system as a Rust library."))}m.isMDXComponent=!0}}]);
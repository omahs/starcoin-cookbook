"use strict";(self.webpackChunkstarcoin_cookbook=self.webpackChunkstarcoin_cookbook||[]).push([[8991],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),u=r,f=m["".concat(l,".").concat(u)]||m[u]||p[u]||a;return n?o.createElement(f,i(i({ref:t},d),{},{components:n})):o.createElement(f,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4300:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return c}});var o=n(3117),r=(n(7294),n(3905));const a={},i="Move VM, Bytecode, and Disassembler",s={unversionedId:"move/move-test/disassembler",id:"move/move-test/disassembler",title:"Move VM, Bytecode, and Disassembler",description:"There are times we wish to understand what's actually going on under the hood when we write a piece of code,",source:"@site/docs/03-move/97-move-test/04-disassembler.md",sourceDirName:"03-move/97-move-test",slug:"/move/move-test/disassembler",permalink:"/docs/move/move-test/disassembler",draft:!1,editUrl:"https://github.com/starcoinorg/starcoin-cookbook/edit/main/docs/03-move/97-move-test/04-disassembler.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"How to debug Move module and troubleshooting",permalink:"/docs/move/move-test/how-to-debug"},next:{title:"Move examples",permalink:"/docs/move/move-examples/"}},l={},c=[{value:"Move VM execution model",id:"move-vm-execution-model",level:2},{value:"Move Disassembler",id:"move-disassembler",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"move-vm-bytecode-and-disassembler"},"Move VM, Bytecode, and Disassembler"),(0,r.kt)("p",null,"There are times we wish to understand what's actually going on under the hood when we write a piece of code,\ncompile it, and execute it in the move VM."),(0,r.kt)("p",null,"In this post, we will take a look at them."),(0,r.kt)("h2",{id:"move-vm-execution-model"},"Move VM execution model"),(0,r.kt)("p",null,"A Move Interpreter handles program execution at the bytecode level."),(0,r.kt)("p",null,"Just like other stack-based interpreters, when seeing an instruction, move interpreters\nmay consume operands from the stack and may push results to it. But unlike x86 machines,\nwhere operands/variables share the same region with the call stack, Move VM logically separate\nthem apart: a Move interpreter has two parts -- An operand stack, and a call stack\n(its internal structure is shown below)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Interpreter\n\u251c\u2500\u2500 operand Stack\n\u2502   \u251c\u2500\u2500 value[0]  <---- stack bottom\n\u2502   \u251c\u2500\u2500 value[1]\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 value[n]  <---- stack top\n\u2514\u2500\u2500 call stack\n    \u251c\u2500\u2500 frame[0]                            <-- Call stack bottom\n    \u2502   \u251c\u2500\u2500 pc (program counter)\n    \u2502   \u251c\u2500\u2500 locals (an array of ValueImpl, contains local variables and paramters)\n    \u2502   \u251c\u2500\u2500 function (a runtime function)\n    \u2502   \u2514\u2500\u2500 ty_args (type arguments)\n    \u251c\u2500\u2500 frame[1]\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 frame[m]                            <-- Call stack top\n")),(0,r.kt)("p",null,"Upon any procedural call, the caller prepares arguments (a.k.a, actual parameters) and pushes them\nto the operand stack, then the ",(0,r.kt)("inlineCode",{parentName:"p"},"Call")," instruction will result in the creation of a new frame\nfor the callee on top of the call stack, where formal parameters are copied from the stack."),(0,r.kt)("p",null,"We can understand most instructions' meaning from their name. Whenever you wonder the effect of\nany instruction, refer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"execute_code_impl()")," in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/starcoinorg/move/blob/main/language/move-vm/runtime/src/move_vm.rs"},"interpreter.rs"),"\nfor details."),(0,r.kt)("h2",{id:"move-disassembler"},"Move Disassembler"),(0,r.kt)("p",null,"Most of the time, Move developers write code, test, and debug at the source level.\nHowever, since bytecode is actually what the Move VM executes, in some rare conditions,\nwe might need to inspect the corresponding bytecode of a particular module or function."),(0,r.kt)("p",null,"For instance, in Starcoin Framework, there's a function ",(0,r.kt)("inlineCode",{parentName:"p"},"owns()")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"IdentiferNFT")," module of\n",(0,r.kt)("inlineCode",{parentName:"p"},"NFT.move"),". Its original implementation is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public fun owns<NFTMeta: copy + store + drop, NFTBody: store>(owner: address): bool acquires IdentifierNFT {\n    if (!exists<IdentifierNFT<NFTMeta, NFTBody>>(owner)) {\n        return false\n    };\n    let id_nft = borrow_global<IdentifierNFT<NFTMeta, NFTBody>>(owner);\n    Option::is_some(&id_nft.nft)\n}\n")),(0,r.kt)("p",null,"Some readers may have noticed that the logic of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"if not X then false else Y")," is\nactually equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"X and Y"),". Therefore, it is tempting to simplify the function to this form\n(let's call it the one-liner version):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public fun owns<NFTMeta: copy + store + drop, NFTBody: store>(owner: address): bool acquires IdentifierNFT {\n    exists<IdentifierNFT<NFTMeta, NFTBody>>(owner)) && \n        Option::is_some(borrow_global<IdentifierNFT<NFTMeta, NFTBody>>(owner)&.nft)\n}\n")),(0,r.kt)("p",null,"But if we try to run the tests, we might notice that the gas fee for the one-liner consumption differs from\nthat of the original version. Why?"),(0,r.kt)("p",null,"Now it's time to examine the bytecode."),(0,r.kt)("p",null,"First, let's check the bytecode of the original implementation.\nTo disassemble the module ",(0,r.kt)("inlineCode",{parentName:"p"},"IdentifierNFT"),", run ",(0,r.kt)("inlineCode",{parentName:"p"},"mpm package disassemble --name IdentifierNFT"),".\nHere's is the result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"owns")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public owns<NFTMeta: copy + drop + store, NFTBody: store>(id_nft: address): bool {\nB0:\n    0: CopyLoc[0](owner: address)\n    1: ExistsGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    2: Not\n    3: BrTrue(5)\nB1:\n    4: Branch(7)\nB2:\n    5: LdFalse\n    6: Ret\nB3:\n    7: CopyLoc[0](owner: address)\n    8: ImmBorrowGlobalGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    9: StLoc[1](id_nft: &IdentifierNFT<NFTMeta, NFTBody>)\n    10: MoveLoc[1](id_nft: &IdentifierNFT<NFTMeta, NFTBody>)\n    11: ImmBorrowFieldGeneric[0](IdentifierNFT.nft: Option<NFT<NFTMeta, NFTBody>>)\n    12: Call[5](is_some<NFT<NFTMeta, NFTBody>>(&Option<NFT<NFTMeta, NFTBody>>): bool)\n    13: Ret\n}\n")),(0,r.kt)("p",null,"Let's try to understand it using what we've learned earlier:\nThere are 4 ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Basic_block"},"basic blocks")," in the function.\nIn B0, it copied the ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," address to the stack, and then use it to do the existence check,\nfollowed by a negation, finally branches to B2 conditionally."),(0,r.kt)("p",null,"B2 simply pushes false and returns."),(0,r.kt)("p",null,"B1 is a dummy block that takes the control flow to B3. It does the global borrow from instruction\n7-8 and store it in ",(0,r.kt)("inlineCode",{parentName:"p"},"id_nft")," at instruction 9. Instruction 10 loads that to the stack again (yes, you\nmight have noticed that a simple peephole optimization can eliminate instructions 9-10. Currently Move\ncompiler doesn't really do much optimization). The last three instructions 11-13 return the result of the\npredicate ",(0,r.kt)("inlineCode",{parentName:"p"},"is_some()")," on field 0."),(0,r.kt)("p",null,"Now let's check the one-liner's bytecode out:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public owns<NFTMeta: copy + drop + store, NFTBody: store>(%#1: address): bool {\nB0:\n    0: CopyLoc[0](owner: address)\n    1: ExistsGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    2: BrTrue(4)\nB1:\n    3: Branch(10)\nB2:\n    4: CopyLoc[0](owner: address)\n    5: ImmBorrowGlobalGeneric[0](IdentifierNFT<NFTMeta, NFTBody>)\n    6: ImmBorrowFieldGeneric[0](IdentifierNFT.nft: Option<NFT<NFTMeta, NFTBody>>)\n    7: Call[5](is_some<NFT<NFTMeta, NFTBody>>(&Option<NFT<NFTMeta, NFTBody>>): bool)\n    8: StLoc[1](%#1: bool)\n    9: Branch(12)\nB3:\n    10: LdFalse\n    11: StLoc[1](%#1: bool)\nB4:\n    12: MoveLoc[1](%#1: bool)\n    13: Ret\n}\n")),(0,r.kt)("p",null,"We won't elaborate on the details here again, since most of the instructions are the same.\nWe can notice a few differences:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"There are more basic blocks in the one-liner version."),(0,r.kt)("li",{parentName:"ol"},"Results are no longer returned directly from the stack.\nNotice that the compiler generated an unnamed local variable ",(0,r.kt)("inlineCode",{parentName:"li"},"%#1"),",\nany value to be returned gets stored into it,\nand finally B4 returns it."),(0,r.kt)("li",{parentName:"ol"},"Redundant instructions 9-10 in the original bytecode no longer exists here, since the one-liner\ndon't have a temporary variable ",(0,r.kt)("inlineCode",{parentName:"li"},"id_nft"),".")),(0,r.kt)("p",null,"Now we fully understand the behavioral difference caused by the refactoring."))}p.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkstarcoin_cookbook=self.webpackChunkstarcoin_cookbook||[]).push([[4251],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3642:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return r},default:function(){return d},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return c}});var a=n(3117),o=(n(7294),n(3905));const i={},r="Verify Smart Contract: Move Prover Tutorials",l={unversionedId:"move/move-prover/mvp-tutorial",id:"move/move-prover/mvp-tutorial",title:"Verify Smart Contract: Move Prover Tutorials",description:"What is Move Prover",source:"@site/docs/03-move/100-move-prover/02-mvp-tutorial.md",sourceDirName:"03-move/100-move-prover",slug:"/move/move-prover/mvp-tutorial",permalink:"/docs/move/move-prover/mvp-tutorial",draft:!1,editUrl:"https://github.com/starcoinorg/starcoin-cookbook/edit/main/docs/03-move/100-move-prover/02-mvp-tutorial.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Move Specification Language",permalink:"/docs/move/move-prover/move-spec-language"},next:{title:"How to Dapp",permalink:"/docs/web3/"}},s={},c=[{value:"What is Move Prover",id:"what-is-move-prover",level:2},{value:"Install Prover dependencies",id:"install-prover-dependencies",level:2},{value:"Prepare an example for verification",id:"prepare-an-example-for-verification",level:2},{value:"Project creation",id:"project-creation",level:3},{value:"Module code",id:"module-code",level:3},{value:"TOML configuration",id:"toml-configuration",level:3},{value:"The first verification code",id:"the-first-verification-code",level:2},{value:"Verify withdraw function",id:"verify-withdraw-function",level:2},{value:"Specify the abort condition for <code>widthdraw</code>",id:"specify-the-abort-condition-for-widthdraw",level:3},{value:"Specify the functional nature of <code>withdraw</code>",id:"specify-the-functional-nature-of-withdraw",level:3},{value:"Verify the <code>deposit</code> function",id:"verify-the-deposit-function",level:2},{value:"Verify the <code>transfer</code> function",id:"verify-the-transfer-function",level:2},{value:"practice",id:"practice",level:3},{value:"Verify mint function",id:"verify-mint-function",level:2},{value:"Verify the <code>publish_balance</code> function",id:"verify-the-publish_balance-function",level:2},{value:"Simplify redundant specification with Schema",id:"simplify-redundant-specification-with-schema",level:2},{value:"Eliminate simple repetitions",id:"eliminate-simple-repetitions",level:3},{value:"Schema composition",id:"schema-composition",level:3},{value:"practice",id:"practice-1",level:3}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"verify-smart-contract-move-prover-tutorials"},"Verify Smart Contract: Move Prover Tutorials"),(0,o.kt)("h2",{id:"what-is-move-prover"},"What is Move Prover"),(0,o.kt)("p",null,"Formal verification is a technique that uses rigorous mathematical methods to describe the behavior and reason about the correctness of computer systems.\nNow it has certain applications in the fields of operating systems, compilers and other fields that require high correctness."),(0,o.kt)("p",null,"Smart contracts deployed on the blockchain manipulate various digital assets, and their correctness is also critical.\n",(0,o.kt)("strong",{parentName:"p"},"Move Prover (MVP)")," is designed to prevent bugs in smart contracts written in the Move language.\nUsers can specify functional properties of smart contracts using the ",(0,o.kt)("strong",{parentName:"p"},"Move Specification Language (MSL)"),", and then use Move Prover to automatically and statically inspect them."),(0,o.kt)("p",null,"Simply put, there can be two components in a Move file:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Part of it is program code, which is the part most of us are most familiar with. It is written in the Move programming language (sometimes just called the Move language). We use it to define data types, functions.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The other part is the Formal specification. It is optional and written in the Move specification language. We use it to describe what properties a program code should satisfy. Such as describing the behavior of a function."))),(0,o.kt)("p",null,"When we write the formal specification, after calling the Move Prover, it will verify whether the Move program meets these requirements according to the written specification, helping developers to find potential problems as early as possible in the development stage, and give other users confidence in the properties of the program that has been verified."),(0,o.kt)("h2",{id:"install-prover-dependencies"},"Install Prover dependencies"),(0,o.kt)("p",null,"Before using Move Prover, let's install some of its external dependencies.\nIt is assumed that you already have a copy of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/starcoinorg/starcoin"},"Starcoin")," source code and have built the project.\nWe switch to the root directory of Starcoin and run the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cd $PATH_TO_STARCOIN\n./scripts/dev_setup.sh -ypt\nsource ~/.profile\n")),(0,o.kt)("p",null,"When the above command is executed, enter ",(0,o.kt)("inlineCode",{parentName:"p"},"boogie /version"),', if the output is similar to "Boogie program verifier version X.X.X", then the installation has been successful.'),(0,o.kt)("p",null,"Note that currently Move Prover can only run under UNIX-based operating systems (such as Linux, macOS).\nWindows users can run it by installing ",(0,o.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/windows/wsl/install"},"WSL"),"."),(0,o.kt)("h2",{id:"prepare-an-example-for-verification"},"Prepare an example for verification"),(0,o.kt)("h3",{id:"project-creation"},"Project creation"),(0,o.kt)("p",null,"First, let's create a new empty Move package:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"mpm package new BasicCoin\n")),(0,o.kt)("p",null,"You can see that its directory structure is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"BasicCoin\n    |\n    |---- Move.toml (text file)\n    |\n    `---- sources   (Directory)\n")),(0,o.kt)("h3",{id:"module-code"},"Module code"),(0,o.kt)("p",null,"Now create ",(0,o.kt)("inlineCode",{parentName:"p"},"BasicCoin/sources/BasicCoin.move"),"."),(0,o.kt)("details",null,(0,o.kt)("summary",null," BasicCoin.move content"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// This module defines a minimal and generic Coin and Balance.\nmodule NamedAddr::BasicCoin {\n    use StarcoinFramework::Errors;\n    use StarcoinFramework::Signer;\n\n    /// Error codes\n    const ENOT_MODULE_OWNER: u64 = 0;\n    const EINSUFFICIENT_BALANCE: u64 = 1;\n    const EALREADY_HAS_BALANCE: u64 = 2;\n\n    struct Coin<phantom CoinType> has store {\n        value: u64\n    }\n\n    struct Balance<phantom CoinType> has key {\n        coin: Coin<CoinType>\n    }\n\n    /// Publish an empty balance resource under `account`'s address. This function must be called before\n    /// minting or transferring to the account.\n    public fun publish_balance<CoinType>(account: &signer) {\n        let empty_coin = Coin<CoinType> { value: 0 };\n        assert!(!exists<Balance<CoinType>>(Signer::address_of(account)), Errors::already_published(EALREADY_HAS_BALANCE));\n        move_to(account, Balance<CoinType> { coin:  empty_coin });\n    }\n\n    /// Mint `amount` tokens to `mint_addr`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can decide the minting policy.\n    public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance {\n        // Deposit `total_value` amount of tokens to mint_addr's balance\n        deposit(mint_addr, Coin<CoinType> { value: amount });\n    }\n\n    public fun balance_of<CoinType>(owner: address): u64 acquires Balance {\n        borrow_global<Balance<CoinType>>(owner).coin.value\n    }\n\n    /// Transfers `amount` of tokens from `from` to `to`. This method requires a witness with `CoinType` so that the\n    /// module that owns `CoinType` can  decide the transferring policy.\n    public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance {\n        let addr_from = Signer::address_of(from);\n        let check = withdraw<CoinType>(addr_from, amount);\n        deposit<CoinType>(to, check);\n    }\n\n    fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance {\n        let balance = balance_of<CoinType>(addr);\n        assert!(balance >= amount, EINSUFFICIENT_BALANCE);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        *balance_ref = balance - amount;\n        Coin<CoinType> { value: amount }\n    }\n\n    fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance{\n        let balance = balance_of<CoinType>(addr);\n        let balance_ref = &mut borrow_global_mut<Balance<CoinType>>(addr).coin.value;\n        let Coin { value } = check;\n        *balance_ref = balance + value;\n    }\n}\n"))),(0,o.kt)("p",null,"Here we assume that you have a certain grasp of the Move language, and can understand the source code of ",(0,o.kt)("inlineCode",{parentName:"p"},"BasicCoin.move")," above and know the function of each part."),(0,o.kt)("h3",{id:"toml-configuration"},"TOML configuration"),(0,o.kt)("p",null,"BasicCoin uses some facilities of the Starcoin standard library, and also needs to add ",(0,o.kt)("inlineCode",{parentName:"p"},"StarcoinFramework")," to the dependencies.\nAt the same time, the named address is used in BasicCoin, and we also need to specify what numerical address it should be replaced with.\nTherefore, we modify Move.toml as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "BasicCoin"\nversion = "0.0.0"\n\n[addresses]\nNamedAddr = "0xcafe"\n\n[dependencies]\nStarcoinFramework = { git = "https://github.com/starcoinorg/starcoin-framework", rev="01c84198819310620f2417413c3c800df8292ae5" }\n')),(0,o.kt)("h2",{id:"the-first-verification-code"},"The first verification code"),(0,o.kt)("p",null,"To give us a first impression of the use of Move Prover, add the following code snippet to BasicCoin.move:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec balance_of {\n    pragma aborts_if_is_strict;\n}\n")),(0,o.kt)("p",null,"Syntactically, this code can be added anywhere in the BasicCoin module, but it is recommended to place it after the definition of the ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," function in order to clearly see the correspondence between the definition and the specification when reading the code."),(0,o.kt)("p",null,"Simply put, the ",(0,o.kt)("inlineCode",{parentName:"p"},"spec balance_of {...}")," block will contain our ",(0,o.kt)("strong",{parentName:"p"},"property specification")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," function.\nThere are many types of property specifications, some common examples are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Will this function abort? Under what circumstances does it abort?"),(0,o.kt)("li",{parentName:"ul"},"What conditions must be met for the parameters to call this function?"),(0,o.kt)("li",{parentName:"ul"},"What is the return value of this function?"),(0,o.kt)("li",{parentName:"ul"},"After the function is executed, how will the state of the virtual machine be changed?"),(0,o.kt)("li",{parentName:"ul"},"What invariants does this function maintain?")),(0,o.kt)("p",null,"For example, Move Prover allows all possible aborts by default when we don't give any abort conditions.\nAnd in the simple snippet above, we tell Prover with the directive ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if_is_strict"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"I would like to strictly check the possibility of aborting this function. Report an error if there is any abort not listed by the programmer.")),(0,o.kt)("p",null,"Now, we run the ",(0,o.kt)("inlineCode",{parentName:"p"},"prove")," command in the ",(0,o.kt)("inlineCode",{parentName:"p"},"BasicCoin")," directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"mpm package prove\n")),(0,o.kt)("p",null,"mpm will call Move Prover to check the code in the package.\nThen we can see the Prover reporting the following error message:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"error: abort not covered by any of the `aborts_if` clauses\n   \u250c\u2500 ./sources/BasicCoin.move:38:5\n   \u2502\n35 \u2502           borrow_global<Balance<CoinType>>(owner).coin.value\n   \u2502           ------------- abort happened here with execution failure\n   \xb7\n38 \u2502 \u256d     spec balance_of {\n39 \u2502 \u2502       pragma aborts_if_is_strict;\n40 \u2502 \u2502     }\n   \u2502 \u2570\u2500\u2500\u2500\u2500\u2500^\n   \u2502\n   =     at ./sources/BasicCoin.move:34: balance_of\n   =         owner = 0x29\n   =     at ./sources/BasicCoin.move:35: balance_of\n   =         ABORTED\n\nError: exiting with verification errors\n")),(0,o.kt)("p",null,"Prover's output tells us that it found a situation where the ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," function aborts, but we don't explicitly point out the possibility of such aborts.\nLooking at the code that triggers the abort, we can see that the exception is caused by calling the built-in ",(0,o.kt)("inlineCode",{parentName:"p"},"borrow_global")," function when the ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," does not own a resource of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Balance<CoinType>"),".\nFollowing the guidance of the error message, we can add the following ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if")," condition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec balance_of {\n    pragma aborts_if_is_strict;\n    aborts_if !exists<Balance<CoinType>>(owner);\n}\n")),(0,o.kt)("p",null,"After adding this condition, try calling Prover again and see that there are no more validation errors.\nNow we can confidently confirm that the ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," function has one and only one possibility of abnormal termination, that is, the parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," does not own a resource of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Balance<CoinType>"),"."),(0,o.kt)("h2",{id:"verify-withdraw-function"},"Verify withdraw function"),(0,o.kt)("p",null,"The signature of the function ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw")," is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fun withdraw<CoinType>(addr: address, amount: u64) : Coin<CoinType> acquires Balance\n")),(0,o.kt)("p",null,"Its role is to withdraw the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of coins from the address ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," and return it."),(0,o.kt)("h3",{id:"specify-the-abort-condition-for-widthdraw"},"Specify the abort condition for ",(0,o.kt)("inlineCode",{parentName:"h3"},"widthdraw")),(0,o.kt)("p",null,"There are two possibilities for ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw")," to abort:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"No resource of type ",(0,o.kt)("inlineCode",{parentName:"li"},"Balance<CoinType>")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"addr"),"."),(0,o.kt)("li",{parentName:"ol"},"The balance in ",(0,o.kt)("inlineCode",{parentName:"li"},"addr")," is less than ",(0,o.kt)("inlineCode",{parentName:"li"},"amount"),".")),(0,o.kt)("p",null,"From these, we can define the abort condition like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A spec block can contain let bindings, which bind a long expression with a name that can be used repeatedly.\n",(0,o.kt)("inlineCode",{parentName:"li"},"global<T>(addr): T")," is a built-in function that returns a resource of type ",(0,o.kt)("inlineCode",{parentName:"li"},"T")," at address ",(0,o.kt)("inlineCode",{parentName:"li"},"addr"),".\nHere, we set balance to the number of tokens owned by addr via the let binding;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"exists<T>(address): bool")," is a built-in function that returns true if resource ",(0,o.kt)("inlineCode",{parentName:"li"},"T")," exists at address ",(0,o.kt)("inlineCode",{parentName:"li"},"addr"),"; otherwise returns false.")),(0,o.kt)("p",null,"The two lines of ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if")," statements correspond to the two conditions mentioned above.\nIn general, if a function has multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if")," conditions, the conditions are ORed together."),(0,o.kt)("p",null,"As mentioned earlier, if we don't specify any abort conditions, Prover will not impose any restrictions on aborts.\nBut once we give any kind of abort conditions, Prover defaults that we want to strictly check all possible aborts, so we need to list all possible conditions, which is equivalent to implicitly adding the instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"pragma aborts_if_is_strict"),".\nIf only some of the conditions for abnormal exit are listed, the Prover will report a validation error.\nHowever, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"pragma aborts_if_is_partial")," is defined in the spec block, this is equivalent to telling the Prover:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"I just want to list some of the conditions that will cause an abort, please just verify that it will abort under those conditions.")),(0,o.kt)("p",null,"If you are interested, you can do such a set of experiments to verify:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When deleting any of the above two ",(0,o.kt)("inlineCode",{parentName:"li"},"aborts_if")," conditions, Prover will report an error;"),(0,o.kt)("li",{parentName:"ul"},"When all ",(0,o.kt)("inlineCode",{parentName:"li"},"aborts_if")," conditions are deleted at the same time, Prover will not report an error;"),(0,o.kt)("li",{parentName:"ul"},"When adding ",(0,o.kt)("inlineCode",{parentName:"li"},"pragma aborts_if_is_partial"),", no matter how many ",(0,o.kt)("inlineCode",{parentName:"li"},"aborts_if")," conditions are kept, Prover will not report an error (of course, the conditions themselves must be correct).")),(0,o.kt)("p",null,"Some readers may be curious about the order of the three statements in the spec block:\nWhy the definition of balance can be written after ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if !exists<Balance<CoinType>>(addr)"),".\nBecause, if the latter holds true, ",(0,o.kt)("inlineCode",{parentName:"p"},"balance")," does not actually exist.\nWouldn't this order cause the Prover to fail?\nSimply put: no, the statements in the spec block are declarative and the order doesn't matter."),(0,o.kt)("p",null,"For a more detailed understanding, you can refer to the MSL documentation for more information."),(0,o.kt)("h3",{id:"specify-the-functional-nature-of-withdraw"},"Specify the functional nature of ",(0,o.kt)("inlineCode",{parentName:"h3"},"withdraw")),(0,o.kt)("p",null,"Next we define functional properties.\nThe two ",(0,o.kt)("inlineCode",{parentName:"p"},"ensures")," statements in the following spec block give us what we expect from the ",(0,o.kt)("inlineCode",{parentName:"p"},"widthdraw")," functionality:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec withdraw {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n    ensures result == Coin<CoinType> { value: amount };\n}\n")),(0,o.kt)("p",null,"In this code, first by using ",(0,o.kt)("inlineCode",{parentName:"p"},"let post")," binding, define ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_post")," as the balance of ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," after the function is executed, it should be equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"balance - amount"),". Then, ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," is a special name that represents the return value, which should be the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of tokens."),(0,o.kt)("h2",{id:"verify-the-deposit-function"},"Verify the ",(0,o.kt)("inlineCode",{parentName:"h2"},"deposit")," function"),(0,o.kt)("p",null,"The signature of the function deposit is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fun deposit<CoinType>(addr: address, check: Coin<CoinType>) acquires Balance\n")),(0,o.kt)("p",null,"It deposits the token funds indicated by ",(0,o.kt)("inlineCode",{parentName:"p"},"check")," into the address ",(0,o.kt)("inlineCode",{parentName:"p"},"addr"),". Its canonical definition is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec deposit {\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    let check_value = check.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + check_value > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + check_value;\n}\n")),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"balance")," is defined as the balance in ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," before the function is executed, and ",(0,o.kt)("inlineCode",{parentName:"p"},"check_value")," is defined as the amount of tokens to be deposited. It will abort in two cases:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"There is no resource of type ",(0,o.kt)("inlineCode",{parentName:"li"},"Balance<CoinType>")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"addr"),";"),(0,o.kt)("li",{parentName:"ol"},"Or the sum of ",(0,o.kt)("inlineCode",{parentName:"li"},"balance")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"check_value")," is greater than the maximum value of type ",(0,o.kt)("inlineCode",{parentName:"li"},"u64"),".")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ensures")," statement is used to let the Prover make sure that in any case, the balance in ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," can be updated correctly after the function is executed."),(0,o.kt)("p",null,"The syntax mentioned earlier will not be repeated here.\nAstute readers may have noticed that it is worth noting that the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"balance + check_value > MAX_U64")," is problematic in the Move program.\nBecause the addition on the left may cause an overflow exception.\nIf we want to write a similar check in the Move program, we should use an expression like ",(0,o.kt)("inlineCode",{parentName:"p"},"balance > MAX_U64 - check_value")," to avoid the overflow problem."),(0,o.kt)("p",null,"However, this expression is perfectly fine in the Move Specification Language (MSL).\nSince the spec block uses the MSL language, its type system is different from that of Move.\nIn MSL, all integers are of type ",(0,o.kt)("inlineCode",{parentName:"p"},"num"),", which is an integer in the mathematical sense. That is, it is signed and has no size limit.\nAll built-in integer types (",(0,o.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"u64"),", etc.) are automatically converted to type ",(0,o.kt)("inlineCode",{parentName:"p"},"num")," when referencing data in a Move program in MSL.\nA more detailed description of the type system can be found in the MSL documentation."),(0,o.kt)("h2",{id:"verify-the-transfer-function"},"Verify the ",(0,o.kt)("inlineCode",{parentName:"h2"},"transfer")," function"),(0,o.kt)("p",null,"The signature of the function ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"public fun transfer<CoinType: drop>(from: &signer, to: address, amount: u64, _witness: CoinType) acquires Balance\n")),(0,o.kt)("p",null,"It is responsible for the transfer ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," the account from to the address ",(0,o.kt)("inlineCode",{parentName:"p"},"to"),", and the transfer amount is ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"."),(0,o.kt)("p",null,"Let's ignore the abort condition for now and only consider its functional nature, and try to write its validation specification:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec transfer {\n    let addr_from = Signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n")),(0,o.kt)("p",null,"Here ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"signer"),", not a direct address.\nAlthough in the program we have created a local variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"addr_from"),", we cannot directly reference it in the spec block.\nAt the same time, the expression of this address needs to be repeated several times, and it is very cumbersome to write repeatedly. We bind it to ",(0,o.kt)("inlineCode",{parentName:"p"},"addr_from")," again.\nThen use ",(0,o.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"let post")," to define several variables, corresponding to the balances in the two addresses ",(0,o.kt)("inlineCode",{parentName:"p"},"addr_from")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," before and after the function is executed.\nFinally, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ensures")," statement to tell Prover that the balance in ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," should be subtracted by ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"; the balance in ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," should be increased by ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"."),(0,o.kt)("p",null,'At first glance, there seems to be no problem at all. But is it really so?\nLet\'s see if Prover thinks this is "the correct description of the behavior of this function".\nAfter typing ',(0,o.kt)("inlineCode",{parentName:"p"},"mpm package prove")," you can see:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"error: post-condition does not hold\n   \u250c\u2500 ./sources/BasicCoin.move:58:9\n   \u2502\n58 \u2502         ensures balance_from_post == balance_from - amount;\n   \u2502         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   \u2502\n   =     at ./sources/BasicCoin.move:45: transfer\n   =     at ./sources/BasicCoin.move:51: transfer (spec)\n   =     at ./sources/BasicCoin.move:53: transfer (spec)\n   =     at ./sources/BasicCoin.move:54: transfer (spec)\n   =     at ./sources/BasicCoin.move:45: transfer\n   =         from = signer{0x0}\n   =         to = 0x0\n   =         amount = 1\n   =         _witness = <generic>\n")),(0,o.kt)("p",null,"It is somewhat out of our expectation. Prover prompts that the postconditions are not satisfied, indicating that the behavior described in the previous spec block is not exactly the same as the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function.\nWhy is this so? Let's look down again: the parameters that make the postconditions are not satisfied are ",(0,o.kt)("inlineCode",{parentName:"p"},"from = signer{0x0}")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"to = 0x0"),". We should know the reason: when the account transfers money to itself, both ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," point to the same address, so the balance does not change."),(0,o.kt)("p",null,"There are two solutions now:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Plan A")," does not modify the function definition, but changes the specification.\nIn the spec block, consider whether the two accounts for the transfer and receiving are the same address."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures (addr_from == to && eq_post) || (addr_from != to && ne_post);\n")),(0,o.kt)("p",null,"Or use another slightly more intuitive if syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let post eq_post = balance_to == balance_to_post;\nlet post ne_post = balance_from_post == balance_from - amount\n                && balance_to_post   == balance_to   + amount;\nensures if (addr_from == to) eq_post else ne_post;\n")),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"if (P) E1 else E2")," is not the same as conditional execution in program logic -- it's actually a syntactic sugar equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"ensures")," both ",(0,o.kt)("inlineCode",{parentName:"p"},"P ==> E1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"!P ==> E2"),".\nAnd ",(0,o.kt)("inlineCode",{parentName:"p"},"p ==> q")," is actually ",(0,o.kt)("inlineCode",{parentName:"p"},"!p || q"),"."),(0,o.kt)("p",null,"That is to say, the end of the second way of writing actually represents this logic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"ensures (addr_from == to  ===>  eq_post) && (addr_from != to  ===> ne_post);\n")),(0,o.kt)("p",null,"that is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"ensures (addr_from != to || eq_post) && (addr_from == to  || ne_post);\n")),(0,o.kt)("p",null,"Interested readers can verify it by themselves through the direct value table or by simplifying to normal form, the former ",(0,o.kt)("inlineCode",{parentName:"p"},"(addr_from == to && eq_post) || (addr_from != to && ne_post)")," and the latter ",(0,o.kt)("inlineCode",{parentName:"p"},"(addr_from != to || eq_post) && (addr_from == to  || ne_post)")," are actually exactly equivalent expressions."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Plan B")," does not modify the spec, but directly adds ",(0,o.kt)("inlineCode",{parentName:"p"},"assert!(from_addr != to, EEQUAL_ADDR)")," in the function body, and adds the definition of the error code ",(0,o.kt)("inlineCode",{parentName:"p"},"EEQUAL_ADDR")," in front, so that the self-transfer transaction cannot be completed."),(0,o.kt)("p",null,"Obviously, it is not meaningful to transfer money to yourself, so it is better to directly prohibit this kind of transaction.\nSo plan B is a better practice.\nIt directly guarantees that the two are definitely not the same address when successfully executed, and the code is more concise."),(0,o.kt)("h3",{id:"practice"},"practice"),(0,o.kt)("p",null,"Currently we have only completed functional verification of the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," function.\nBut it doesn't say under what circumstances it will abort.\nAs an exercise, give it an appropriate ",(0,o.kt)("inlineCode",{parentName:"p"},"aborts_if")," condition. The answer can be found in later chapters. TODO"),(0,o.kt)("h2",{id:"verify-mint-function"},"Verify mint function"),(0,o.kt)("p",null,"The signature of the function ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"public fun mint<CoinType: drop>(mint_addr: address, amount: u64, _witness: CoinType) acquires Balance\n")),(0,o.kt)("p",null,"It is responsible for minting the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," of tokens and depositing them in the address ",(0,o.kt)("inlineCode",{parentName:"p"},"mint_addr"),".\nMore interesting is ",(0,o.kt)("inlineCode",{parentName:"p"},"_witness"),", which is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"CoinType"),".\nBecause only the module that defines the ",(0,o.kt)("inlineCode",{parentName:"p"},"CoinType")," can construct a value of this type, this guarantees the identity of the caller."),(0,o.kt)("p",null,"There is actually only one call to ",(0,o.kt)("inlineCode",{parentName:"p"},"deposit")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," function.\nIt is not difficult to imagine that there should be many similarities in the specifications to be satisfied by the two. Drawing a tiger according to a cat, it is not difficult to write:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec mint {\n    let balance = global<Balance<CoinType>>(mint_addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(mint_addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(mint_addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n")),(0,o.kt)("h2",{id:"verify-the-publish_balance-function"},"Verify the ",(0,o.kt)("inlineCode",{parentName:"h2"},"publish_balance")," function"),(0,o.kt)("p",null,"The signature of the function ",(0,o.kt)("inlineCode",{parentName:"p"},"publish_balance")," is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"public fun publish_balance<CoinType>(account: &signer)\n")),(0,o.kt)("p",null,"It publishes an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"Balance<CoinType>")," resource under ",(0,o.kt)("inlineCode",{parentName:"p"},"account"),".\nSo if the resource already exists it should exit abnormally, and end normally the balance should be zero:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec publish_balance {\n    let addr = Signer::address_of(account);\n    aborts_if exists<Balance<CoinType>>(addr);\n\n    ensures exists<Balance<CoinType>>(addr);\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == 0;\n}\n")),(0,o.kt)("h2",{id:"simplify-redundant-specification-with-schema"},"Simplify redundant specification with Schema"),(0,o.kt)("p",null,"Congratulations! So far, we have completed the verification of all the functions of BasicCoin step by step.\nHowever, if you look closely at the code, many of the spec blocks look very similar, and the file structure would be clearer if they could be shortened a bit."),(0,o.kt)("p",null,"Schema is a means of building a specification by grouping properties.\nSemantically, they are also syntactic sugar, and their use in a spec block is equivalent to expanding the conditions they contain into functions, structs, or modules."),(0,o.kt)("h3",{id:"eliminate-simple-repetitions"},"Eliminate simple repetitions"),(0,o.kt)("p",null,"As a most obvious example, the spec blocks of ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"deposit")," are a little different except for the variable names (in terms, they are ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B1-conversion"},"alpha convertible"),"), and the overall structure can be said to be exactly the same.\nTo simplify them, let's create a Schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec schema DepositSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance + amount > MAX_U64;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance + amount;\n}\n")),(0,o.kt)("p",null,"This Schema declares two typed variables, and some conditions about what those variables should satisfy.\nWhen other places want to use this Schema, use ",(0,o.kt)("inlineCode",{parentName:"p"},"include DepositSchema {addr: XX, amount: YY}")," to import it.\nwhere ",(0,o.kt)("inlineCode",{parentName:"p"},"XX")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"YY")," are expressions used to replace ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),".\nIf the expression is exactly the same as the corresponding variable name, you can just write the variable name, or simply omit it."),(0,o.kt)("p",null,"With the above Schema definition, we can now simplify the previous spec:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec mint {\n  include DepositSchema<CoinType> {addr: mint_addr};\n}\n// ....\nspec deposit {\n    include DepositSchema<CoinType> {amount: check.value};\n}\n")),(0,o.kt)("h3",{id:"schema-composition"},"Schema composition"),(0,o.kt)("p",null,"Schema can not only eliminate the above almost the same repetition, but also can be combined to form a more complex specification."),(0,o.kt)("p",null,"If you experimented and completed the exercises through each step of the tutorial, the spec for your ",(0,o.kt)("inlineCode",{parentName:"p"},"tranfer")," function should now look something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// initial version\nspec transfer {\n    let addr_from = Signer::address_of(from);\n\n    let balance_from = global<Balance<CoinType>>(addr_from).coin.value;\n    let balance_to = global<Balance<CoinType>>(to).coin.value;\n    let post balance_from_post = global<Balance<CoinType>>(addr_from).coin.value;\n    let post balance_to_post = global<Balance<CoinType>>(to).coin.value;\n\n    aborts_if !exists<Balance<CoinType>>(addr_from);\n    aborts_if !exists<Balance<CoinType>>(to);\n    aborts_if balance_from < amount;\n    aborts_if balance_to + amount > MAX_U64;\n    aborts_if addr_from == to;\n\n    ensures balance_from_post == balance_from - amount;\n    ensures balance_to_post == balance_to + amount;\n}\n")),(0,o.kt)("p",null,"Although it is relatively complicated, it is not difficult to see after a little analysis that it actually combines the two logics of ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"deposit"),".\nThis can also be analyzed from the calling relationship of transfer."),(0,o.kt)("p",null,"In the previous step, we already have ",(0,o.kt)("inlineCode",{parentName:"p"},"DepositSchema"),". Now, let's refactor the validation specification for ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw"),": extract it into a Schema, and a spec block that uses the Schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"spec withdraw {\n    include WithdrawSchema<CoinType>;\n    ensures result == Coin<CoinType> { value: amount };\n}\n\nspec schema WithdrawSchema<CoinType> {\n    addr: address;\n    amount: u64;\n\n    let balance = global<Balance<CoinType>>(addr).coin.value;\n    aborts_if !exists<Balance<CoinType>>(addr);\n    aborts_if balance < amount;\n\n    let post balance_post = global<Balance<CoinType>>(addr).coin.value;\n    ensures balance_post == balance - amount;\n}\n")),(0,o.kt)("p",null,"With these two schemas, we can easily rewrite the validation specification of ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// After refactoring with Schema\nspec transfer {\n    let addr_from = Signer::address_of(from);\n\n    include WithdrawSchema<CoinType> { addr: addr_from };\n    include DepositSchema<CoinType> { addr: to };\n\n    aborts_if addr_from == to;\n}\n")),(0,o.kt)("p",null,"how about it? Compared with the original version, it is much simpler and clearer now."),(0,o.kt)("h3",{id:"practice-1"},"practice"),(0,o.kt)("p",null,"In addition to the above example, find another spec block (such as ",(0,o.kt)("inlineCode",{parentName:"p"},"publish_balance"),"), and split it into a Schema declaration and a spec block that uses the corresponding Schema.\nAs an exercise, the Schema you created might not be available in this code, so it doesn't feel like there's much benefit to it.\nBut if in the later development, there are other functions that call ",(0,o.kt)("inlineCode",{parentName:"p"},"publish_balance"),", it will be more convenient."))}d.isMDXComponent=!0}}]);
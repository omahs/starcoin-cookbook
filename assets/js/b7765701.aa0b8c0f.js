"use strict";(self.webpackChunkstarcoin_cookbook=self.webpackChunkstarcoin_cookbook||[]).push([[3770],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=u(t),m=o,_=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return t?a.createElement(_,s(s({ref:n},c),{},{components:t})):a.createElement(_,s({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,s=new Array(i);s[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7941:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return p},frontMatter:function(){return i},metadata:function(){return r},toc:function(){return u}});var a=t(3117),o=(t(7294),t(3905));const i={},s="Unit Tests",r={unversionedId:"move/move-test/move-unit-test",id:"move/move-test/move-unit-test",title:"Unit Tests",description:"Unit testing for Move adds three new annotations to the Move source language:",source:"@site/docs/03-move/97-move-test/01-move-unit-test.md",sourceDirName:"03-move/97-move-test",slug:"/move/move-test/move-unit-test",permalink:"/starcoin-cookbook/docs/move/move-test/move-unit-test",draft:!1,editUrl:"https://github.com/starcoinorg/starcoin-cookbook/edit/main/docs/03-move/97-move-test/01-move-unit-test.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Move test",permalink:"/starcoin-cookbook/docs/move/move-test/"},next:{title:"Write Move integration test",permalink:"/starcoin-cookbook/docs/move/move-test/move-integration-test"}},l={},u=[{value:"Testing Annotations: Their Meaning and Usage",id:"testing-annotations-their-meaning-and-usage",level:2},{value:"Running Unit Tests",id:"running-unit-tests",level:2},{value:"Example",id:"example",level:2},{value:"Running Tests",id:"running-tests",level:2},{value:"Using Test Flags",id:"using-test-flags",level:2}],c={toc:u};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"unit-tests"},"Unit Tests"),(0,o.kt)("p",null,"Unit testing for Move adds three new annotations to the Move source language:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"#[test]")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"#[test_only]")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"#[expected_failure]"))),(0,o.kt)("p",null,"They respectively mark a function as a test, mark a module or module member (",(0,o.kt)("inlineCode",{parentName:"p"},"use"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"fun"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"struct"),") as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test_only]")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test]"),", it will not be included in the compiled bytecode unless it is compiled for testing."),(0,o.kt)("h2",{id:"testing-annotations-their-meaning-and-usage"},"Testing Annotations: Their Meaning and Usage"),(0,o.kt)("p",null,"Both the ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"#[expected_failure]")," annotations can be used either with or without arguments."),(0,o.kt)("p",null,"Without arguments, the ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test]")," annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#[test] // OK\nfun this_is_a_test() { ... }\n\n#[test] // Will fail to compile since the test takes an argument\nfun this_is_not_correct(arg: signer) { ... }\n")),(0,o.kt)("p",null,"A test can also be annotated as an ",(0,o.kt)("inlineCode",{parentName:"p"},"#[expected_failure]"),". This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with ",(0,o.kt)("inlineCode",{parentName:"p"},"#[expected_failure(abort_code = <code>)]"),", if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test]")," annotation can also be annotated as an ",(0,o.kt)("inlineCode",{parentName:"p"},"#[expected_failure]"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#[test]\n#[expected_failure]\npublic fun this_test_will_abort_and_pass() { abort 1 }\n\n#[test]\n#[expected_failure]\npublic fun test_will_error_and_pass() { 1/0; }\n\n#[test]\n#[expected_failure(abort_code = 0)]\npublic fun test_will_error_and_fail() { 1/0; }\n\n#[test, expected_failure] // Can have multiple in one attribute. This test will pass.\npublic(script) fun this_other_test_will_abort_and_pass() { abort 1 }\n")),(0,o.kt)("p",null,"With arguments, a test annotation takes the form ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test(<param_name_1> = <address>, ..., <param_name_n> = <address>)]"),". If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters ",(0,o.kt)("inlineCode",{parentName:"p"},"<param_name_1>, ..., <param_name_n>"),", i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name."),(0,o.kt)("p",null,"Only parameters with a type of ",(0,o.kt)("inlineCode",{parentName:"p"},"signer")," are supported as test parameters. If a ",(0,o.kt)("inlineCode",{parentName:"p"},"non-signer")," parameter is supplied, the test will result in an error when run."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#[test(arg = @0xC0FFEE)] // OK\nfun this_is_correct_now(arg: signer) { ... }\n\n#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match\nfun this_is_incorrect(arg: signer) { ... }\n\n#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument\nfun this_works(a: signer, b: signer) { ... }\n\n// somewhere a named address is declared\n#[test_only] // test-only named addresses are supported\naddress TEST_NAMED_ADDR = @0x1;\n...\n#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!\nfun this_is_correct_now(arg: signer) { ... }\n")),(0,o.kt)("p",null,"An expected failure annotation can also take the form ",(0,o.kt)("inlineCode",{parentName:"p"},"#[expected_failure(abort_code = <u64>)]"),". If a test function is annotated in such a way, the test must abort with an abort code equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"<u64>"),". Any other failure or abort code will result in a test failure."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#[test, expected_failure(abort_code = 1)] // This test will fail\nfun this_test_should_abort_and_fail() { abort 0 }\n\n#[test]\n#[expected_failure(abort_code = 0)] // This test will pass\nfun this_test_should_abort_and_pass_too() { abort 0 }\n")),(0,o.kt)("p",null,"A module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test ",(0,o.kt)("inlineCode",{parentName:"p"},"use")," s of a ",(0,o.kt)("inlineCode",{parentName:"p"},"#[test_only]")," module will raise an error during compilation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"#[test_only] // test only attributes can be attached to modules\nmodule ABC { ... }\n\n#[test_only] // test only attributes can be attached to named addresses\naddress ADDR = @0x1;\n\n#[test_only] // .. to uses\nuse 0x1::SomeOtherModule;\n\n#[test_only] // .. to structs\nstruct SomeStruct { ... }\n\n#[test_only] // .. and functions. Can only be called from test code, but not a test\nfun test_only_function(...) { ... }\n")),(0,o.kt)("h2",{id:"running-unit-tests"},"Running Unit Tests"),(0,o.kt)("p",null,"Unit tests for a Move package can be run with the ",(0,o.kt)("inlineCode",{parentName:"p"},"move package test")," command."),(0,o.kt)("p",null,"When running tests, every test will either ",(0,o.kt)("inlineCode",{parentName:"p"},"PASS"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"FAIL"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMEOUT"),". If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below."),(0,o.kt)("p",null,"A test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see ",(0,o.kt)("inlineCode",{parentName:"p"},"OPTIONS")," below)."),(0,o.kt)("p",null,"There are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag:\n",(0,o.kt)("inlineCode",{parentName:"p"},"mpm pacakge -h")),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"A simple module using some of the unit testing features is shown in the following example:"),(0,o.kt)("p",null,"First create an empty package and change directory into it:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"$ move package new TestExample; cd TestExample")),(0,o.kt)("p",null,"Next add the following to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Move.toml"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// filename: sources/MyModule.move\nmodule 0x1::MyModule {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n")),(0,o.kt)("p",null,"Next add the following module under the ",(0,o.kt)("inlineCode",{parentName:"p"},"sources")," directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// filename: sources/MyModule.move\nmodule 0x1::MyModule {\n\n    struct MyCoin has key { value: u64 }\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, 0);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    // Or #[expected_failure] if we don't care about the abort code\n    #[expected_failure(abort_code = 0)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only] // test only helper function\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n")),(0,o.kt)("h2",{id:"running-tests"},"Running Tests"),(0,o.kt)("p",null,"You can then run these tests with the ",(0,o.kt)("inlineCode",{parentName:"p"},"mpm package test")," command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ mpm package test\nBUILDING MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n\n")),(0,o.kt)("h2",{id:"using-test-flags"},"Using Test Flags"),(0,o.kt)("p",null,"Type ",(0,o.kt)("inlineCode",{parentName:"p"},"<str>")," following ",(0,o.kt)("inlineCode",{parentName:"p"},"mpm package test"),", which will only run tests whose fully qualified name contains ",(0,o.kt)("inlineCode",{parentName:"p"},"<str>"),". For example, if we want to only run tests with ",(0,o.kt)("inlineCode",{parentName:"p"},'"zero_coin"')," in their name:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ mpm package test zero_coin\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\nTest result: OK. Total tests: 2; passed: 2; failed: 0\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"-i <bound>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"--instructions <bound>")),(0,o.kt)("p",null,"This bounds the number of instructions that can be executed for any one test to ",(0,o.kt)("inlineCode",{parentName:"p"},"<bound>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ mpm package test -i 0\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ TIMEOUT ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ TIMEOUT ] 0x1::MyModule::make_sure_zero_coin_fails\n[ TIMEOUT ] 0x1::MyModule::test_has_coin\n\nTest failures:\n\nFailures in 0x1::MyModule:\n\n\u250c\u2500\u2500 make_sure_non_zero_coin_passes \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 Test timed out\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\n\u250c\u2500\u2500 make_sure_zero_coin_fails \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 Test timed out\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\n\u250c\u2500\u2500 test_has_coin \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 Test timed out\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nTest result: FAILED. Total tests: 3; passed: 0; failed: 3\n\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"-s")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"--statistics"),"\nWith these flags you can gather statistics about the tests run and report the runtime and instructions executed for each test. For example, if we wanted to see the statistics for the tests in the example above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ mpm package test -s\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\n\nTest Statistics:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Test Name                   \u2502    Time    \u2502   Instructions Executed   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0x1::MyModule::make_sure_non_zero_coin_passes \u2502   0.009    \u2502             1             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0x1::MyModule::make_sure_zero_coin_fails      \u2502   0.008    \u2502             1             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0x1::MyModule::test_has_coin                  \u2502   0.008    \u2502             1             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"-g")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"--state-on-error"),"\nThese flags will print the global state for any test failures. e.g., if we added the following (failing) test to the ",(0,o.kt)("inlineCode",{parentName:"p"},"MyModule")," example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"module 0x1::MyModule {\n    ...\n    #[test(a = @0x1)]\n    fun test_has_coin_bad(a: signer) {\n        publish_coin(&a);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n    }\n}\n")),(0,o.kt)("p",null,"we would get get the following output when running the tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ mpm package test -g\nCACHED MoveStdlib\nBUILDING TestExample\nRunning Move unit tests\n[ PASS    ] 0x1::MyModule::make_sure_non_zero_coin_passes\n[ PASS    ] 0x1::MyModule::make_sure_zero_coin_fails\n[ PASS    ] 0x1::MyModule::test_has_coin\n[ FAIL    ] 0x1::MyModule::test_has_coin_bad\n\nTest failures:\n\nFailures in 0x1::MyModule:\n\n\u250c\u2500\u2500 test_has_coin_bad \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 error[E11001]: test failure\n\u2502    \u250c\u2500 /home/tzakian/TestExample/sources/MyModule.move:47:10\n\u2502    \u2502\n\u2502 44 \u2502      fun test_has_coin_bad(a: signer) {\n\u2502    \u2502          ----------------- In this function in 0x1::MyModule\n\u2502    \xb7\n\u2502 47 \u2502          assert!(has_coin(@0x2), 1);\n\u2502    \u2502          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here\n\u2502\n\u2502\n\u2502 \u2500\u2500\u2500\u2500\u2500\u2500 Storage state at point of failure \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 0x1:\n\u2502       => key 0x1::MyModule::MyCoin {\n\u2502           value: 1\n\u2502       }\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nTest result: FAILED. Total tests: 4; passed: 3; failed: 1\n")))}p.isMDXComponent=!0}}]);